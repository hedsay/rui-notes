(window.webpackJsonp=window.webpackJsonp||[]).push([[256],{580:function(e,v,l){"use strict";l.r(v);var s=l(4),t=Object(s.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[e._v("Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。\n可以通过修改配置文件来设置Redis的最大内存：")]),e._v(" "),v("div",{staticClass:"language-properties line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-properties"}},[v("code",[v("span",{pre:!0,attrs:{class:"token key attr-name"}},[e._v("maxmemory")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token value attr-value"}},[e._v("1gb")]),e._v("\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("h2",{attrs:{id:"过期策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#过期策略"}},[e._v("#")]),e._v(" 过期策略")]),e._v(" "),v("p",[e._v("【1】Redis是如何知道一个key是否过期呢？")]),e._v(" "),v("p",[e._v("利用两个Dict分别记录key-value对及key-ttl对：Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在之前学习过的Dict结构中。不过在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL。")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://aurora-nr.oss-cn-beijing.aliyuncs.com/1653983423128.png",alt:""}})]),e._v(" "),v("p",[v("img",{attrs:{src:"https://aurora-nr.oss-cn-beijing.aliyuncs.com/1653983606531.png",alt:""}})]),e._v(" "),v("hr"),e._v(" "),v("p",[e._v("【2】是不是TTL到期就立即删除了呢？")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("惰性删除：不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。")])]),e._v(" "),v("li",[v("p",[e._v("周期删除：通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。执行周期有两种：")]),e._v(" "),v("ol",[v("li",[e._v("Redis服务初始化函数initServer()中设置定时任务，按照server.hz的频率来执行过期key清理，模式为SLOW")]),e._v(" "),v("li",[e._v("Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST")])]),e._v(" "),v("p",[e._v("SLOW模式规则：")]),e._v(" "),v("ul",[v("li",[e._v("执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。")]),e._v(" "),v("li",[e._v("执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms")]),e._v(" "),v("li",[e._v("逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期")]),e._v(" "),v("li",[e._v("如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束")])]),e._v(" "),v("p",[e._v("FAST模式规则（过期key比例小于10%不执行 ）：")]),e._v(" "),v("ul",[v("li",[e._v("执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms")]),e._v(" "),v("li",[e._v("执行清理耗时不超过1ms")]),e._v(" "),v("li",[e._v("逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期\n如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束")])])])]),e._v(" "),v("h2",{attrs:{id:"内存淘汰策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存淘汰策略"}},[e._v("#")]),e._v(" 内存淘汰策略")]),e._v(" "),v("p",[e._v("当Redis内存使用达到设置的上限时，主动挑选部分key删除以释放更多内存的流程。")]),e._v(" "),v("p",[e._v("Redis支持8种不同策略来选择要删除的key：")]),e._v(" "),v("ul",[v("li",[e._v("noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。")]),e._v(" "),v("li",[e._v("volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰")]),e._v(" "),v("li",[e._v("allkeys-random：对全体key ，随机进行淘汰。也就是直接从db->dict中随机挑选")]),e._v(" "),v("li",[e._v("volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db->expires中随机挑选。")]),e._v(" "),v("li",[e._v("allkeys-lru： 对全体key，基于LRU算法进行淘汰")]),e._v(" "),v("li",[e._v("volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰")]),e._v(" "),v("li",[e._v("allkeys-lfu： 对全体key，基于LFU算法进行淘汰")]),e._v(" "),v("li",[e._v("volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰")])]),e._v(" "),v("blockquote",[v("ul",[v("li",[e._v("LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。")]),e._v(" "),v("li",[e._v("LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。高16位以每分钟为单位记录最近一次访问时间，低8位记录逻辑访问次数")])])]),e._v(" "),v("p",[e._v("LFU的访问次数之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：")]),e._v(" "),v("ul",[v("li",[e._v("生成0~1之间的随机数R")]),e._v(" "),v("li",[e._v("计算 (旧次数 * lfu_log_factor + 1)，记录为P")]),e._v(" "),v("li",[e._v("如果 R < P ，则计数器 + 1，且最大不超过255")]),e._v(" "),v("li",[e._v("访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1")])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://aurora-nr.oss-cn-beijing.aliyuncs.com/1653984085095.png",alt:""}})])])}),[],!1,null,null,null);v.default=t.exports}}]);