(window.webpackJsonp=window.webpackJsonp||[]).push([[246],{570:function(_,v,t){"use strict";t.r(v);var e=t(4),a=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"何为事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#何为事务"}},[_._v("#")]),_._v(" 何为事务？")]),_._v(" "),v("p",[_._v("事务分为：分布式事务，数据库事务；")]),_._v(" "),v("p",[_._v("数据库事务：多个对数据库的操作构成一个整体逻辑，要么全部执行，要不全不执行；")]),_._v(" "),v("div",{staticClass:"language-sql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("START")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("TRANSACTION")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\nSQL1"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v("SQL2"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("COMMIT")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br")])]),v("h2",{attrs:{id:"事务四大特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务四大特性"}},[_._v("#")]),_._v(" 事务四大特性")]),_._v(" "),v("blockquote",[v("p",[_._v("ACID")])]),_._v(" "),v("p",[_._v("A(原子性)：事务是最小执行单位，要么全部完成，要么完全不起作用；")]),_._v(" "),v("p",[_._v("C(一致性)：事务前后，数据一致；")]),_._v(" "),v("p",[_._v("I(隔离性)：并发访问数据库，一个用户的事务不被其它事务干扰；")]),_._v(" "),v("p",[_._v("D(持久性)：事务提交后，对数据库里的数据是持久的；")]),_._v(" "),v("p",[_._v("AID是手段，C是目的；")]),_._v(" "),v("blockquote",[v("p",[_._v("如何保证？")]),_._v(" "),v("p",[_._v("原子性通过 undo log 来保证；")]),_._v(" "),v("p",[_._v("隔离性通过 MVCC 或 锁机制 来保证；")]),_._v(" "),v("p",[_._v("持久性通过 redo log 来保证；")]),_._v(" "),v("p",[_._v("一致性通过 原子性+隔离性+持久性来保证；")])]),_._v(" "),v("h2",{attrs:{id:"并发事务带来的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并发事务带来的问题"}},[_._v("#")]),_._v(" 并发事务带来的问题？")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("脏读：一个事务读到 另一个未提交事务修改过的数据 ；")]),_._v(" "),v("blockquote",[v("p",[_._v("A事务读取到B事务未提交修改的数据，B后续还有可能回滚，所以A读取到一个脏数据；")])])]),_._v(" "),v("li",[v("p",[_._v("不可重复读：同一个事务多次读取同一个数据，前后读到的数据不一致；")])]),_._v(" "),v("li",[v("p",[_._v("幻读：同一个事务查询符合查询条件的 记录数量，前后查询数量不一致；")])])]),_._v(" "),v("h2",{attrs:{id:"事务隔离级别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离级别"}},[_._v("#")]),_._v(" 事务隔离级别")]),_._v(" "),v("ul",[v("li",[_._v("读未提交：一个事务未提交，修改的数据被其它事务看见；")]),_._v(" "),v("li",[_._v("读已提交：只有事务提交，修改的数据才能被其他事务看见；")]),_._v(" "),v("li",[_._v("可重复读：事务启动后，所有数据是一致的；（InnoDB默认）")]),_._v(" "),v("li",[_._v("串行化：对记录加锁，多个事务执行这条记录时，发生读写冲突，后访问事务必须等前一个事务执行完成；")])]),_._v(" "),v("blockquote",[v("p",[_._v("隔离级别如何实现？")]),_._v(" "),v("p",[_._v("读未提交：读取最新数据；")]),_._v(" "),v("p",[_._v("读已提交：在每条语句执行前，生成ReadView；")]),_._v(" "),v("p",[_._v("可重复读：启动事务时，生成ReadView，整个事务期间，都是用这个ReadView;")]),_._v(" "),v("p",[_._v("串行化：读写锁；")])]),_._v(" "),v("h2",{attrs:{id:"innodb可重复读如何解决幻读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#innodb可重复读如何解决幻读"}},[_._v("#")]),_._v(" InnoDB可重复读如何解决幻读？")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("快照读，通过MVCC解决了幻读；")]),_._v(" "),v("blockquote",[v("p",[_._v("可重复读下，开启事务后，在执行第一个查询语句后，会创建一个Read View，后续的查询语句会利用这个Read View，通过这个Read View可以在undo log版本连找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据；")])])]),_._v(" "),v("li",[v("p",[_._v("当前读，通过临键锁解决了幻读；")]),_._v(" "),v("blockquote",[v("p",[_._v("其他事务在临键锁范围内插入一条记录，这个插入语句被阻塞；")])])])]),_._v(" "),v("h2",{attrs:{id:"readview在mvcc如何工作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#readview在mvcc如何工作"}},[_._v("#")]),_._v(" ReadView在MVCC如何工作？")]),_._v(" "),v("p",[v("strong",[_._v("ReadView 4个重要字段：")])]),_._v(" "),v("ol",[v("li",[_._v("creator_trx_id ：创建该 Read View 的事务的事务 id;")]),_._v(" "),v("li",[_._v("m_ids : 在创建 Read View 时，当前数据库中「活跃事务」的"),v("strong",[_._v("事务 id 列表")]),_._v(";")]),_._v(" "),v("li",[_._v("min_trx_id ：在创建 Read View 时，当前数据库中「活跃事务」中事务 "),v("strong",[_._v("id 最小的事务")]),_._v("，也就是 m_ids 的最小值;")]),_._v(" "),v("li",[_._v("max_trx_id ：全局事务中最大的事务 id 值 + 1;")])]),_._v(" "),v("p",[v("strong",[_._v("聚簇索引记录隐藏列：")])]),_._v(" "),v("ol",[v("li",[_._v("trx_id：当前事务的事务id；")]),_._v(" "),v("li",[_._v("roll_pointer：指向undo版本链的指针；")])]),_._v(" "),v("p",[_._v("创建Read View后，记录中trx_id的三种情况：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/ReadView.drawio.png",alt:"img"}})]),_._v(" "),v("ul",[v("li",[_._v("如果记录的 "),v("code",[_._v("trx_id")]),_._v(" 值小于 Read View 中的 "),v("code",[_._v("min_trx_id")]),_._v(" 值，表示这个版本的记录是在创建 Read View "),v("strong",[_._v("前")]),_._v("已经提交的事务生成的，所以该版本的记录对当前事务"),v("strong",[_._v("可见")]),_._v(";")]),_._v(" "),v("li",[_._v("如果记录的 "),v("code",[_._v("trx_id")]),_._v(" 值大于等于 Read View 中的 "),v("code",[_._v("max_trx_id")]),_._v(" 值，表示这个版本的记录是在创建 Read View "),v("strong",[_._v("后")]),_._v("才启动的事务生成的，所以该版本的记录对当前事务"),v("strong",[_._v("不可见")]),_._v(";")]),_._v(" "),v("li",[_._v("如果记录的 "),v("code",[_._v("trx_id")]),_._v(" 值在 Read View 的 "),v("code",[_._v("min_trx_id")]),_._v(" 和 "),v("code",[_._v("max_trx_id")]),_._v(" 之间，需要判断 "),v("code",[_._v("trx_id")]),_._v(" 是否在 "),v("code",[_._v("m_ids")]),_._v(" 列表中：\n"),v("ol",[v("li",[_._v("如果记录的 "),v("code",[_._v("trx_id")]),_._v(" "),v("strong",[_._v("在")]),_._v(" "),v("code",[_._v("m_ids")]),_._v(" 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务"),v("strong",[_._v("不可见")]),_._v(";")]),_._v(" "),v("li",[_._v("如果记录的 "),v("code",[_._v("trx_id")]),_._v(" "),v("strong",[_._v("不在")]),_._v(" "),v("code",[_._v("m_ids")]),_._v("列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务"),v("strong",[_._v("可见")]),_._v(";")])])])]),_._v(" "),v("h2",{attrs:{id:"innodb可重复读可以完全解决幻读吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#innodb可重复读可以完全解决幻读吗"}},[_._v("#")]),_._v(" InnoDB可重复读可以完全解决幻读吗？")]),_._v(" "),v("blockquote",[v("p",[_._v("先快照读 后当前读；")])]),_._v(" "),v("ul",[v("li",[_._v("T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id > 100 得到了 3 条记录。")]),_._v(" "),v("li",[_._v("T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；")]),_._v(" "),v("li",[_._v("T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id > 100 for update 就会得到 4 条记录，此时也发生了幻读现象。")])]),_._v(" "),v("p",[v("strong",[_._v("在开启事务之后，马上执行 select ... for update 这类当前读的语句")]),_._v("，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录;")]),_._v(" "),v("h2",{attrs:{id:"临键锁是否可以防止删除操作导致的幻读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#临键锁是否可以防止删除操作导致的幻读"}},[_._v("#")]),_._v(" 临键锁是否可以防止删除操作导致的幻读？")]),_._v(" "),v("blockquote",[v("p",[_._v("可以，删除语句陷入等待状态；")])])])}),[],!1,null,null,null);v.default=a.exports}}]);