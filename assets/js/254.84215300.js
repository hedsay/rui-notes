(window.webpackJsonp=window.webpackJsonp||[]).push([[254],{578:function(v,_,t){"use strict";t.r(_);var e=t(4),a=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"rdb"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[v._v("#")]),v._v(" RDB")]),v._v(" "),_("blockquote",[_("p",[v._v("全量快照，把内存中的所有数据都记录到磁盘中，当Redis实例故障重启后，从磁盘读取快照文件，恢复数据；")]),v._v(" "),_("p",[v._v("RDB文件内容是二进制数据；")])]),v._v(" "),_("h3",{attrs:{id:"触发时机"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#触发时机"}},[v._v("#")]),v._v(" 触发时机")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("执行save命令")]),v._v(" "),_("blockquote",[_("p",[v._v("在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会阻塞主线程；")])])]),v._v(" "),_("li",[_("p",[v._v("执行bgsave命令")]),v._v(" "),_("blockquote",[_("p",[v._v("fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入 新的 RDB 文件，替换掉旧的RDB文件，避免主线程阻塞；")]),v._v(" "),_("p",[v._v("fork采用的是copy-on-write写时复制技术：")]),v._v(" "),_("ul",[_("li",[v._v("当主进程执行读操作时，访问共享内存；")]),v._v(" "),_("li",[v._v("当主进程执行写操作时，则会拷贝一份数据，执行写操作。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://aurora-nr.oss-cn-beijing.aliyuncs.com/image-20210725151319695.png",alt:""}})]),v._v(" "),_("p",[v._v("（主进程只能操作虚拟内存，操作系统会维护虚拟内存到物理内存的映射关系表：页表，创建子进程时，会复制父进程的页表，但页表指向的物理内存还是一个，只有在内存数据修改时，物理内存才会被复制一份）")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/ebd620db8a1af66fbeb8f4d4ef6adc68.png",alt:"图片"}})]),v._v(" "),_("p",[v._v("执行快照时，数据能被修改吗？")]),v._v(" "),_("p",[v._v("答：能，bgsave快照过程中，如果主线程修改了共享数据，发生了写时复制后，RDB 快照保存的是原本的内存数据，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照；")])])])]),v._v(" "),_("h3",{attrs:{id:"缺陷"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺陷"}},[v._v("#")]),v._v(" 缺陷")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("RDB执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多（而 AOF 日志可以以秒级的方式记录操作命令，所以丢失的数据就相对更少）；")])]),v._v(" "),_("li",[_("p",[v._v("bgsave命令在fork子进程、压缩、写出RDB文件都比较耗时；")])])]),v._v(" "),_("h2",{attrs:{id:"aof"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[v._v("#")]),v._v(" AOF")]),v._v(" "),_("blockquote",[_("p",[v._v("记录的是"),_("strong",[v._v("命令")]),v._v("；RDB记录的是数据，恢复大量数据的时候，RDB更快；")]),v._v(" "),_("p",[v._v("保存写操作到日志的持久化方式；")]),v._v(" "),_("p",[v._v("开启AOF：redis.conf")]),v._v(" "),_("div",{staticClass:"language-properties line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-properties"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 是否开启AOF功能，默认是no")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token key attr-name"}},[v._v("appendonly")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token value attr-value"}},[v._v("yes")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# AOF文件的名称")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token key attr-name"}},[v._v("appendfilename")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token value attr-value"}},[v._v('"appendonly.aof"')]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br")])])]),v._v(" "),_("h3",{attrs:{id:"比rdb的优势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#比rdb的优势"}},[v._v("#")]),v._v(" 比RDB的优势？")]),v._v(" "),_("blockquote",[_("p",[v._v("安全性更好，生成RDB文件过程更繁重，虽然bgsave不会阻塞主线程，但是也会影响CPU资源和内存资源；")]),v._v(" "),_("p",[v._v("AOF支持秒级的数据丢失（写回策略设置为everysec）；")]),v._v(" "),_("p",[v._v("不建议单独使用AOF，可以同时开启RDB和AOF持久化；")])]),v._v(" "),_("h3",{attrs:{id:"写回策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#写回策略"}},[v._v("#")]),v._v(" 写回策略")]),v._v(" "),_("p",[v._v("Redis是先执行写操作命令后，再将该命令记录到AOF日志中；")]),v._v(" "),_("blockquote",[_("p",[v._v("为什么不 WAL？")]),v._v(" "),_("p",[v._v("答：像mysql中redolog 记录的是数据，AOF记录的是命令；")]),v._v(" "),_("p",[v._v("好处：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("避免额外检查开销")]),v._v("：如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错；")])]),v._v(" "),_("p",[v._v("风险：")]),v._v(" "),_("ol",[_("li",[v._v("数据丢失风险：先写日志，宕机，还没来得及写磁盘；")]),v._v(" "),_("li",[_("strong",[v._v("给下条命令带来阻塞风险")]),v._v("：写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行（执行命令与写日志操作都是主进程完成的，同步操作），如果将日志内容写入到硬盘时，服务器的硬盘的 I/O 压力太大，就会导致写硬盘的速度很慢，进而阻塞住了，也就会导致后续的命令无法执行；")])]),v._v(" "),_("p",[v._v("这两个风险都和AOF写回磁盘的时机相关，空值每个命令执行后AOF日志写回磁盘就可以解决；")])]),v._v(" "),_("p",[v._v("Redis写入AOF日志过程：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png",alt:"img"}})]),v._v(" "),_("ol",[_("li",[_("p",[v._v("Redis 执行完写操作命令后，会将命令追加到 "),_("code",[v._v("server.aof_buf")]),v._v(" 缓冲区；")])]),v._v(" "),_("li",[_("p",[v._v("然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；")])]),v._v(" "),_("li",[_("p",[v._v("具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。")]),v._v(" "),_("blockquote",[_("p",[v._v("在 "),_("code",[v._v("redis.conf")]),v._v(" 配置文件中的 "),_("code",[v._v("appendfsync")]),v._v(" 配置项可以有以下 3 种参数可填：")]),v._v(" "),_("ul",[_("li",[v._v("Always：每次写操作命令执行完，同步将AOF日志数据写回磁盘，能保证数据不丢失，但是影响主进程性能；")]),v._v(" "),_("li",[v._v("No：先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回磁盘，不由Redis控制，性能好，但是服务器宕机会丢失数据；")]),v._v(" "),_("li",[v._v("Everysec：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到磁盘；")])]),v._v(" "),_("p",[v._v("底层实现：fsync()函数调用时机")]),v._v(" "),_("ul",[_("li",[v._v("Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数；")]),v._v(" "),_("li",[v._v("Everysec 策略就会创建一个异步任务来执行 fsync() 函数；")]),v._v(" "),_("li",[v._v("No 策略就是永不执行 fsync() 函数；")])])])])]),v._v(" "),_("h3",{attrs:{id:"重写机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重写机制"}},[v._v("#")]),v._v(" 重写机制")]),v._v(" "),_("blockquote",[_("p",[v._v("Redis为了避免AOF文件越写越大，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件；")]),v._v(" "),_("p",[v._v("重写时，读取当前数据库的所有键值对，然后将每一个键值对用一条命令记录到 新的AOF文件 中，记录完成后，将新的 AOF 文件替换现有的 AOF 文件；")])]),v._v(" "),_("p",[v._v("总结：重写机制目的就是针对被反复修改某些键值对，只需要记录它的最终状态；而重写时需要用新的AOF文件覆盖现有的AOF文件，是为了防止重写过程失败，现有的AOF文件收到污染；")]),v._v(" "),_("p",[v._v("AOF后台重写：")]),v._v(" "),_("blockquote",[_("p",[v._v("不会阻塞主线程；")]),v._v(" "),_("p",[v._v("fork重写子进程，如果主进程修改了已存在的 k-v，就触发写时复制，只会复制主进程修改的物理内存数据，没修改的物理内存还是与子进程共享的；")]),v._v(" "),_("p",[v._v("如果主进程又修改了数据，如何解决主进程与子进程数据不一致？")]),v._v(" "),_("p",[v._v("答：")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("重写缓冲区，当Redis执行完一条命令后，同时将这个命令写入到AOF缓冲区和AOF重写缓冲区；")])]),v._v(" "),_("li",[_("p",[v._v("当子进程完成 AOF 重写工作（扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志）后，向主进程发送信号，主进程收到信号后，调用一个信号处理函数，将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，覆盖现有AOF文件；")])])])]),v._v(" "),_("h2",{attrs:{id:"bigkey对持久化影响"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bigkey对持久化影响"}},[v._v("#")]),v._v(" BigKey对持久化影响")]),v._v(" "),_("ol",[_("li",[v._v("AOF写回策略配置为Always，如果为大key，主线程执行fsync()函数时，阻塞的时间比较久；")]),v._v(" "),_("li",[v._v("AOF重写机制与RDB的bgsave命令，若触发写时复制，会拷贝物理内存，大key的物理内存占用很大，在复制阶段会阻塞父进程；")])]),v._v(" "),_("blockquote",[_("p",[v._v("其它影响：")]),v._v(" "),_("ul",[_("li",[v._v("网络阻塞：对 BigKey 执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢；")]),v._v(" "),_("li",[v._v("数据倾斜：集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大；")])]),v._v(" "),_("p",[v._v("查找大key："),_("code",[v._v("redis-cli -a 密码 --bigkeys")])]),v._v(" "),_("p",[v._v("异步删除大key："),_("code",[v._v("unlink")])]),v._v(" "),_("p",[v._v("大Key的优化方案：")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("对大key进行拆分；")])]),v._v(" "),_("li",[_("p",[v._v("对大key进行清理；")]),v._v(" "),_("blockquote",[_("p",[v._v("采用unlink命令安全删除，或通过定时任务方式对失效数据定期清理；")])])])])]),v._v(" "),_("blockquote",[_("p",[v._v("问：假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？")]),v._v(" "),_("table",[_("tr",{staticStyle:{color:"red"}},[_("td",[v._v("key")]),v._v(" "),_("td",[v._v("field")]),v._v(" "),_("td",[v._v("value")])]),v._v(" "),_("tr",[_("td",{attrs:{rowspan:"3"}},[v._v("someKey")]),v._v(" "),_("td",[v._v("id:0")]),v._v(" "),_("td",[v._v("value0")])]),v._v(" "),_("tr",[_("td",[v._v(".....")]),v._v(" "),_("td",[v._v(".....")])]),v._v(" "),_("tr",[_("td",[v._v("id:999999")]),v._v(" "),_("td",[v._v("value999999")])])]),v._v(" "),_("p",[v._v("存在的问题：hash的 entry数量超过500时，会使用哈希表而不是ZipList，内存占用较多；可以通过hash-max-ziplist-entries配置entry上限。但是如果entry过多就会导致BigKey问题；")]),v._v(" "),_("p",[v._v("解决：拆分为小的hash，将 id / 100 作为key， 将id % 100 作为field，这样每100个元素为一个Hash")]),v._v(" "),_("table",[_("tr",{staticStyle:{color:"red"}},[_("td",[v._v("key")]),v._v(" "),_("td",[v._v("field")]),v._v(" "),_("td",[v._v("value")])]),v._v(" "),_("tr",[_("td",{attrs:{rowspan:"3"}},[v._v("key:0")]),v._v(" "),_("td",[v._v("id:00")]),v._v(" "),_("td",[v._v("value0")])]),v._v(" "),_("tr",[_("td",[v._v(".....")]),v._v(" "),_("td",[v._v(".....")])]),v._v(" "),_("tr",[_("td",[v._v("id:99")]),v._v(" "),_("td",[v._v("value99")])]),v._v(" "),_("tr",[_("td",{attrs:{rowspan:"3"}},[v._v("key:1")]),v._v(" "),_("td",[v._v("id:00")]),v._v(" "),_("td",[v._v("value100")])]),v._v(" "),_("tr",[_("td",[v._v(".....")]),v._v(" "),_("td",[v._v(".....")])]),v._v(" "),_("tr",[_("td",[v._v("id:99")]),v._v(" "),_("td",[v._v("value199")])]),v._v(" "),_("tr",[_("td",{attrs:{colspan:"3"}},[v._v("....")])]),v._v(" "),_("tr",[_("td",{attrs:{rowspan:"3"}},[v._v("key:9999")]),v._v(" "),_("td",[v._v("id:00")]),v._v(" "),_("td",[v._v("value999900")])]),v._v(" "),_("tr",[_("td",[v._v(".....")]),v._v(" "),_("td",[v._v(".....")])]),v._v(" "),_("tr",[_("td",[v._v("id:99")]),v._v(" "),_("td",[v._v("value999999")])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);