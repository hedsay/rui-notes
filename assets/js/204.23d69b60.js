(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{528:function(v,_,a){"use strict";a.r(_);var l=a(4),t=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"类的生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类的生命周期"}},[v._v("#")]),v._v(" 类的生命周期")]),v._v(" "),_("ul",[_("li",[v._v("加载")]),v._v(" "),_("li",[v._v("链接")]),v._v(" "),_("li",[v._v("初始化")]),v._v(" "),_("li",[v._v("使用")]),v._v(" "),_("li",[v._v("卸载")])]),v._v(" "),_("h2",{attrs:{id:"类加载过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载过程"}},[v._v("#")]),v._v(" 类加载过程")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("加载")]),v._v(" "),_("blockquote",[_("p",[v._v("由类加载器完成，每个Java类都有一个引用指向加载它的ClassLoader；")]),v._v(" "),_("ol",[_("li",[v._v("获取此类的二进制字节流；")]),v._v(" "),_("li",[v._v("将字节流中的静态存储结构（一些字节）转换为方法区的运行时数据结构；")]),v._v(" "),_("li",[v._v("在内存生成一个代表该类的Class对象；")])])])]),v._v(" "),_("li",[_("p",[v._v("链接")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("验证；")]),v._v(" "),_("p",[v._v("确保Class文件的字节流符合规范；")])]),v._v(" "),_("li",[_("p",[v._v("准备")]),v._v(" "),_("p",[v._v("正式为类变量分配内存并设置类变量初始值；")]),v._v(" "),_("blockquote",[_("p",[v._v("类变量为static修饰的变量，类变量所使用的内存在方法去中分配；")])])]),v._v(" "),_("li",[_("p",[v._v("解析")]),v._v(" "),_("p",[v._v("将运行时常量池内的符号引用替换为直接引用；")])])])]),v._v(" "),_("li",[_("p",[v._v("初始化")]),v._v(" "),_("blockquote",[_("p",[v._v("类初始化的6种情况：")]),v._v(" "),_("ol",[_("li",[v._v("new 一个类，读取一个静态字段（未被final修饰），调用一个类的静态方法；")]),v._v(" "),_("li",[v._v("反射调用，如果类没有初始化，需要初始化；")]),v._v(" "),_("li",[v._v("初始化一个类，父类没有初始化，先初始化父类；")]),v._v(" "),_("li",[v._v("虚拟机启动，初始化包含main方法的类；")]),v._v(" "),_("li",[_("code",[v._v("MethodHandle")]),v._v(" 和 "),_("code",[v._v("VarHandle")]),v._v(" 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，就必须先使用 "),_("code",[v._v("findStaticVarHandle")]),v._v(" 来初始化要调用的类；")]),v._v(" "),_("li",[v._v("当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化；")])])])])]),v._v(" "),_("h2",{attrs:{id:"类加载器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[v._v("#")]),v._v(" 类加载器")]),v._v(" "),_("blockquote",[_("p",[v._v("每个 Java 类都有一个引用指向加载它的 "),_("code",[v._v("ClassLoader")]),v._v("；")]),v._v(" "),_("p",[v._v("数组类不是通过 "),_("code",[v._v("ClassLoader")]),v._v(" 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的；")])]),v._v(" "),_("p",[v._v("加载规则？")]),v._v(" "),_("blockquote",[_("p",[v._v("JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载；")])]),v._v(" "),_("p",[v._v("类加载器？")]),v._v(" "),_("blockquote",[_("p",[_("strong",[v._v("BootstrapClassLoader(启动类加载器)")]),v._v("：加载 JDK 内部的核心类库；")]),v._v(" "),_("p",[_("strong",[v._v("ExtensionClassLoader(扩展类加载器)")]),v._v("：主要负责加载 "),_("code",[v._v("%JRE_HOME%/lib/ext")]),v._v(" 目录下的 jar 包和类以及被 "),_("code",[v._v("java.ext.dirs")]),v._v(" 系统变量所指定的路径下的所有类；")]),v._v(" "),_("p",[_("strong",[v._v("AppClassLoader(应用程序类加载器)")]),v._v("：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类；")])]),v._v(" "),_("p",[v._v("双亲委派模型？")]),v._v(" "),_("blockquote",[_("p",[v._v("ClassLoader类使用委托模型来搜索加载类；")]),v._v(" "),_("p",[v._v("除了顶层启动类加载器，每个类加载器都有自己的父类加载器，ClassLoader实例会在试图亲自加载类之前，将加载类的任务委托给父类加载器；")])]),v._v(" "),_("p",[v._v("打破双亲委派模型？")]),v._v(" "),_("blockquote",[_("p",[v._v("重写loadClass()方法；")])])])}),[],!1,null,null,null);_.default=t.exports}}]);