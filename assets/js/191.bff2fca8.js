(window.webpackJsonp=window.webpackJsonp||[]).push([[191],{514:function(s,t,a){"use strict";a.r(t);var n=a(4),e=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"mesi"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mesi"}},[s._v("#")]),s._v(" MESI")]),s._v(" "),t("blockquote",[t("p",[s._v("缓存一致性协议；")]),s._v(" "),t("p",[s._v("由于计算机的内存与CPU的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲。但是也为计算机系统带来了更高的复杂度，因为它引入了一个新的问题：缓存一致性。")])]),s._v(" "),t("p",[s._v("MESI协议保证每个缓存中使用的共享变量的副本是一致的；")]),s._v(" "),t("p",[s._v("核心思想：当CPU写数据时，如果操作的变量是共享变量（其它CPU中存在该变量副本），会发出信号通知其它CPU将该变量的缓存行置为无效状态；因此，当其它CPU读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，就会从内存中重新读取；")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://aurora-nr.oss-cn-beijing.aliyuncs.com/20240229223323.png",alt:""}})]),s._v(" "),t("h2",{attrs:{id:"volatile与jmm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#volatile与jmm"}},[s._v("#")]),s._v(" volatile与JMM")]),s._v(" "),t("p",[s._v("happens-before 是 JMM 最核心的概念；")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("JMM把happens-before要求禁止的重排序分为两类：会改变/不会改变程序执行结果的重排序，对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序；")])]),s._v(" "),t("li",[t("p",[s._v("JMM的happens-before向程序员提供了足够强的内存可见性保证；")])])]),s._v(" "),t("h2",{attrs:{id:"如何保证可见性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证可见性"}},[s._v("#")]),s._v(" 如何保证可见性？")]),s._v(" "),t("p",[s._v("volatile修饰变量：告知程序任何对该变量的访问均需要从共享内存中获取，而对它的修改必须同步刷新回共享内存；")]),s._v(" "),t("p",[t("strong",[s._v("volatile")]),s._v("和"),t("strong",[s._v("synchronized")]),s._v("和"),t("strong",[s._v("final")]),s._v("关键字都能保证可见性；")]),s._v(" "),t("ul",[t("li",[t("p",[t("strong",[s._v("volatile")]),s._v("是禁用CPU缓存实现的，将处理器计算结果全部同步到主内存中，其它线程读取到的数据都是主存中最新值；")]),s._v(" "),t("blockquote",[t("p",[s._v("volatile是底层靠读屏障，写屏障；")]),s._v(" "),t("p",[s._v("读屏障保证屏障之前的对共享变量的改动都同步到主存中了；")]),s._v(" "),t("p",[s._v("写屏障保证屏障之后的对共享变量读取都是主存中最新的；")])])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("synchronized")]),s._v("是解锁之前，把所有变量同步回主内存中；")])]),s._v(" "),t("li",[t("p",[s._v("被"),t("strong",[s._v("final")]),s._v("修饰的字段在构造器初始化完成，并且构造器没有把this的引用传递出去，该字段对其它线程可见；")])])]),s._v(" "),t("h2",{attrs:{id:"如何保证有序性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证有序性"}},[s._v("#")]),s._v(" 如何保证有序性？")]),s._v(" "),t("p",[t("strong",[s._v("synchronized")]),s._v("：是单线程对一个变量操作;")]),s._v(" "),t("p",[t("strong",[s._v("volatile")]),s._v("：底层是"),t("code",[s._v("Unsafe")]),s._v("类提供的内存屏障方法，对应到JVM上的load，store，read，write等原子方法；")]),s._v(" "),t("h2",{attrs:{id:"volatile原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#volatile原理"}},[s._v("#")]),s._v(" Volatile原理")]),s._v(" "),t("p",[s._v("如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条"),t("strong",[s._v("LOCK前缀的指令")]),s._v("，将这个变量所在缓存行的数据写回系统内存；")]),s._v(" "),t("p",[s._v("对volatile变量进行读操作，直接去主内存中读；")]),s._v(" "),t("p",[s._v("在多核处理器下，为了保证各个处理器缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存中；")]),s._v(" "),t("p",[s._v("实现原则：")]),s._v(" "),t("ol",[t("li",[s._v("Lock前缀指令会引起处理器缓存回写到内存；")]),s._v(" "),t("li",[s._v("一个处理器的缓存回写到内存会导致其它处理器的缓存无效；")])]),s._v(" "),t("h2",{attrs:{id:"双检锁单例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双检锁单例"}},[s._v("#")]),s._v(" 双检锁单例")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Singleton")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("volatile")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Singleton")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("INSTANCE")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Singleton")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("getInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("INSTANCE")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("synchronized")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Singleton")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n                "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("INSTANCE")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n                    "),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("INSTANCE")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Singleton")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n                "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("INSTANCE")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br")])]),t("ol",[t("li",[t("p",[s._v("为什么需要两次判空？")]),s._v(" "),t("p",[s._v("主要是synchronzied里面的判空：ab两个线程一开始都判断为空过来抢锁，a抢到锁，创建对象后释放锁，b线程已经进入第一个判断逻辑，还会认为自己是空，抢到锁之后，如果没有第二次判断空，还会创建对象；")])]),s._v(" "),t("li",[t("p",[s._v("为什么需要volatile关键字？")]),s._v(" "),t("p",[s._v("防止指令重排序，创建对象分三步：分配内存，初始化，将instance指向分配的内存；")]),s._v(" "),t("p",[s._v("23容易指令重排序，A线程刚分配内存，还没初始化，将instance指向了分配的内存，此时B线程过来发现不为null，返回了一个还没初始化的对象；")])])])])}),[],!1,null,null,null);t.default=e.exports}}]);