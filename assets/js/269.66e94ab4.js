(window.webpackJsonp=window.webpackJsonp||[]).push([[269],{594:function(t,v,a){"use strict";a.r(v);var s=a(4),_=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"为什么需要分布式锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要分布式锁"}},[t._v("#")]),t._v(" 为什么需要分布式锁？")]),t._v(" "),v("blockquote",[v("p",[t._v("对于单机多线程来说，在Java中，通常使用 "),v("code",[t._v("ReetrantLock")]),t._v(" 类、"),v("code",[t._v("synchronized")]),t._v(" 关键字这类 JDK 自带的 "),v("strong",[t._v("本地锁")]),t._v(" 来控制一个 JVM 进程内的多个线程对本地共享资源的访问；")]),t._v(" "),v("p",[t._v("分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了；")]),t._v(" "),v("p",[t._v("举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。")])]),t._v(" "),v("h2",{attrs:{id:"分布式锁具备哪些条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁具备哪些条件"}},[t._v("#")]),t._v(" 分布式锁具备哪些条件？")]),t._v(" "),v("ul",[v("li",[t._v("互斥；")]),t._v(" "),v("li",[t._v("高可用：一个锁服务出现问题，能够自动切换到另外一个锁服务；并且，即使客户端的锁释放代码出现问题，锁最终一定还是会被释放，超时机制实现；")]),t._v(" "),v("li",[t._v("可重入：一个节点获取锁之后，还可以再次获取锁；")])])])}),[],!1,null,null,null);v.default=_.exports}}]);