(window.webpackJsonp=window.webpackJsonp||[]).push([[205],{530:function(t,s,a){"use strict";a.r(s);var n=a(4),v=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"死亡对象判断"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#死亡对象判断"}},[t._v("#")]),t._v(" 死亡对象判断")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("引用计数法")]),t._v(" "),s("blockquote",[s("p",[t._v("无法解决循环引用问题")])])]),t._v(" "),s("li",[s("p",[t._v("可达性分析")]),t._v(" "),s("blockquote",[s("p",[t._v("GC ROOTS对象作为起点搜索引用链，不在引用链上的对象为垃圾；")]),t._v(" "),s("p",[t._v("如何判断废弃常量？")]),t._v(" "),s("blockquote",[s("p",[t._v("JDK1.7之后，字符串常量池在堆中，如果没有任何String对象引用该字符串，就说明该常量为废弃常量；")])]),t._v(" "),s("p",[t._v("如何判断无用类？")]),t._v(" "),s("blockquote",[s("ol",[s("li",[t._v("所有类实例被回收；")]),t._v(" "),s("li",[t._v("加载该类的ClassLoader被回收；")]),t._v(" "),s("li",[t._v("该类对应的Class对象不被引用，不被反射访问；")])]),t._v(" "),s("p",[t._v("满足以上条件，“可以回收”，并非立即回收；")])])])])]),t._v(" "),s("h2",{attrs:{id:"哪些对象可以作为gc-roots"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哪些对象可以作为gc-roots"}},[t._v("#")]),t._v(" 哪些对象可以作为GC ROOTS？")]),t._v(" "),s("ul",[s("li",[t._v("栈中引用的对象")]),t._v(" "),s("li",[t._v("方法区类静态属性引用的对象；")]),t._v(" "),s("li",[t._v("方法区常量引用的对象；")])]),t._v(" "),s("h2",{attrs:{id:"垃圾回收算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[t._v("#")]),t._v(" 垃圾回收算法")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("标记清除")]),t._v(" "),s("p",[t._v("大量不连续内存碎片")])]),t._v(" "),s("li",[s("p",[t._v("复制算法")]),t._v(" "),s("p",[t._v("可用内存缩小为一半，不适用老年代（对象多，复制性能差）")])]),t._v(" "),s("li",[s("p",[t._v("标记整理")]),t._v(" "),s("p",[t._v("适用于老年代回收频率不高的场景")])]),t._v(" "),s("li",[s("p",[t._v("分代收集")]),t._v(" "),s("p",[t._v("将堆分为新生代和老年代，新生代每次回收有大量对象死去，选择标记复制算法，老年代选择标记清除/整理算法；")]),t._v(" "),s("blockquote",[s("p",[t._v("对象何时从新生代进入老年代?")]),t._v(" "),s("blockquote",[s("p",[t._v("长期存活的对象，对象在Survivor中每熬过一次MinorGC，年龄就+1，默认15，就可晋升到老年代；")]),t._v(" "),s("p",[t._v("可以通过参数 "),s("code",[t._v("-XX:MaxTenuringThreshold")]),t._v(" 来设置；")])])])])]),t._v(" "),s("h2",{attrs:{id:"三色标记法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三色标记法"}},[t._v("#")]),t._v(" 三色标记法")]),t._v(" "),s("blockquote",[s("p",[t._v("参考文章："),s("a",{attrs:{href:"https://juejin.cn/post/7211470769578147899?searchId=20231020150412890534137EB1201AEB6A",target:"_blank",rel:"noopener noreferrer"}},[t._v("JVM 垃圾回收算法详解（CMS、三色标记）"),s("OutboundLink")],1)])]),t._v(" "),s("p",[t._v("并发标记阶段由于用户线程和GC线程同时运行，会造成已经标记过的对象引用发生变化，会产生多标，漏标问题，漏标采用三色标记法解决；")]),t._v(" "),s("p",[s("strong",[t._v("三色标记算法 把Gc Roots 可达性分析算法过程中遍历的对象")]),t._v("，"),s("strong",[t._v("按照“是否访问过”这个条件标记成以下三种颜色：")])]),t._v(" "),s("p",[s("strong",[t._v("黑色")]),t._v("：表示对象已经被垃圾收集器访问过并且从这个对象出发的多有引用都已经标记过。 如果一个新的标量指向一个黑色对象是不需要重新扫描一遍。黑色对象不可能直接指向白色对象（跳过灰色对象）；")]),t._v(" "),s("p",[s("strong",[t._v("灰色")]),t._v("：表示对象已经被垃圾收集器访问过 但是至少存在1条以上的引用未被扫描过；")]),t._v(" "),s("p",[s("strong",[t._v("白色")]),t._v("：表示未被扫描的对象。显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达；")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://aurora-nr.oss-cn-beijing.aliyuncs.com/20240229224555.png",alt:""}})]),t._v(" "),s("p",[t._v("准备扫表B→D 之前，此时用户线程 删除了B-D 的引用，增加了A-D 的引用，此时根据可达性分析是无法到达D, 显然D又不是垃圾对象，如果将D 按垃圾对象清除，就是JVM一个非常严重的bug；")]),t._v(" "),s("h2",{attrs:{id:"写屏障"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#写屏障"}},[t._v("#")]),t._v(" 写屏障")]),t._v(" "),s("p",[t._v("所谓写屏障就是在复制前后增加一些操作（类似以AOP概念）")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("oop_field_store")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oop"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" field"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" oop new_value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pre_write_barrier")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("field"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("          "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 写屏障-写前操作")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("field "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new_value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("post_write_barrier")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("field"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 写屏障-写后操作")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[s("strong",[t._v("写屏障实现SATB")])]),t._v(" "),s("blockquote",[s("p",[t._v("G1")])]),t._v(" "),s("p",[t._v("当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d = null），我们可以利用写屏障，将B"),s("strong",[t._v("原来成员变量的引用")]),t._v("对象D记录下来：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pre_write_barrier")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oop"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" field"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    oop old_value "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("field"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取旧值")]),t._v("\n    remark_set"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("old_value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 记录原来的引用对象 记录B-D引用，当并发标记扫描结束，重新标记阶段我们可以从remark_set 取出B-D 应用直接将D对象标记为黑色 (G1垃圾收集器采用次算法)")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[s("strong",[t._v("写屏障实现增量更新")])]),t._v(" "),s("blockquote",[s("p",[t._v("CMS")])]),t._v(" "),s("p",[t._v("当对象A的成员变量的引用发生变化时，比如新增引用（a.d = d），我们可以利用写屏障，将A"),s("strong",[t._v("新的成员变量引用")]),t._v("对象D记录下来：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("post_write_barrier")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oop"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" field"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" oop new_value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \n    remark_set"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("new_value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 记录新引用的对象 记录A->D 的引用")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("h2",{attrs:{id:"cms"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cms"}},[t._v("#")]),t._v(" CMS")]),t._v(" "),s("blockquote",[s("p",[t._v("基于标记清除算法，一种以获取最短回收停顿时间为目标的收集器，配合ParNew一起使用；")])]),t._v(" "),s("p",[t._v("运行过程：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://aurora-nr.oss-cn-beijing.aliyuncs.com/20240229224623.png",alt:""}})]),t._v(" "),s("ol",[s("li",[t._v("初始标记：stw，标记GC Roots对象；")]),t._v(" "),s("li",[t._v("并发标记：GC线程和用户线程一起工作，通过可达性分析，标记的是GC ROOTS引用链上的对象。这个阶段由于用户线程继续运行，可能导致已经标记过的对象状态发生改变；")]),t._v(" "),s("li",[t._v("重新标记：stw，主要标记并发标记阶段用户线程运行导致对象引用产生变动的那一部分对象（主要是处理漏标问题），采用三色标记法中的增量更新算法标记；")]),t._v(" "),s("li",[t._v("并发清理：GC线程与用户线程并发；")])]),t._v(" "),s("p",[t._v("缺点：")]),t._v(" "),s("ol",[s("li",[t._v("对CPU 资源敏感和用户线程抢占CPU；")]),t._v(" "),s("li",[t._v("浮动垃圾；（标记清除算法）")])]),t._v(" "),s("h2",{attrs:{id:"g1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#g1"}},[t._v("#")]),t._v(" G1")]),t._v(" "),s("blockquote",[s("p",[t._v("满足GC停顿时间要求同时，具备高吞吐量的垃圾收集器；")]),t._v(" "),s("p",[t._v("将堆区划分为多个大小相等的 Region，每个 Region功能可能会动态变化（年轻代或老年代）；")])]),t._v(" "),s("p",[s("strong",[t._v("Young GC：")])]),t._v(" "),s("p",[t._v("执行时机：计算Eden区回收时间，如果<<设定的参数( -XX:MaxGCPauseMills )，优先增加年轻代的Region，否则触发Young GC；")]),t._v(" "),s("p",[s("strong",[t._v("Mixed GC：")])]),t._v(" "),s("p",[t._v("执行时机：老年代的堆区占有率打到设定参数（-XX:InitiatingHeapOccupancyPercent），采用复制算法，拷贝过程如果没有足够的空Region，触发Full GC；")]),t._v(" "),s("p",[t._v("运行过程：分为"),s("strong",[t._v("标记")]),t._v("阶段，"),s("strong",[t._v("清理")]),t._v("阶段，"),s("strong",[t._v("复制")]),t._v("阶段；")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("标记阶段")]),t._v("：")]),t._v(" "),s("p",[t._v("初始标记：同CMS（STW）")]),t._v(" "),s("p",[t._v("并发标记：同CMS")]),t._v(" "),s("p",[t._v("最终标记：同CMS（SATB）")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("清理阶段：")])]),t._v(" "),s("p",[t._v("筛选回收：对回收价值排序，根据用户期望停顿时间制定回收计划；（STW）")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("复制阶段：")])]),t._v(" "),s("p",[t._v("转移：分配新内存和复制对象的成员变量；（STW）")])])]),t._v(" "),s("p",[t._v("缺点：")]),t._v(" "),s("ol",[s("li",[t._v("记忆集记录跨region引用，使用写屏障维护记忆集操作；")]),t._v(" "),s("li",[t._v("复制阶段需要STW，停顿时间瓶颈；")])]),t._v(" "),s("h2",{attrs:{id:"zgc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#zgc"}},[t._v("#")]),t._v(" ZGC")]),t._v(" "),s("blockquote",[s("p",[t._v("参考："),s("a",{attrs:{href:"https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("新一代垃圾回收器ZGC的探索与实践 - 美团技术团队 (meituan.com)"),s("OutboundLink")],1)])]),t._v(" "),s("blockquote",[s("p",[t._v("将将标记，转移，重定位阶段都做到了几乎并发的垃圾收集器；")])]),t._v(" "),s("p",[t._v("运行过程：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p0.meituan.net/travelcube/40838f01e4c29cfe5423171f08771ef8156393.png@1812w_940h_80q",alt:"img"}})]),t._v(" "),s("p",[s("strong",[t._v("关键技术")]),t._v("："),s("strong",[t._v("染色指针")]),t._v("和"),s("strong",[t._v("读屏障")]),t._v("技术，解决了转移过程中准确访问对象的问题，实现了并发转移。")]),t._v(" "),s("p",[s("strong",[t._v("并发转移问题")]),t._v("：GC线程在转移对象的过程中，应用线程也在不停地访问对象，如果对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误；")]),t._v(" "),s("p",[s("strong",[t._v("原理")]),t._v("：使用染色指针判断对象是否被移动，如果发现被移动，“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址；")])])}),[],!1,null,null,null);s.default=v.exports}}]);