(window.webpackJsonp=window.webpackJsonp||[]).push([[249],{572:function(t,l,a){"use strict";a.r(l);var s=a(4),o=Object(s.a)({},(function(){var t=this,l=t._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h2",{attrs:{id:"主从复制"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#主从复制"}},[t._v("#")]),t._v(" 主从复制")]),t._v(" "),l("h3",{attrs:{id:"实现原理"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[t._v("#")]),t._v(" 实现原理")]),t._v(" "),l("p",[t._v("依赖于binlog（记录 MySQL 上的所有变化并以二进制形式保存在磁盘上），复制过程就是将 binlog 中的数据从主库传输到从库上；")]),t._v(" "),l("p",[l("img",{attrs:{src:"https://aurora-nr.oss-cn-beijing.aliyuncs.com/20240301124806.png",alt:""}})]),t._v(" "),l("p",[t._v("这个过程一般是"),l("strong",[t._v("异步")]),t._v("的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成；")]),t._v(" "),l("p",[t._v("具体步骤：")]),t._v(" "),l("ol",[l("li",[t._v("主库收到客户端提交事务请求后，先写入binlog，再提交事务，更新存储引擎数据，事务提交完成后，返回给客户端成功响应；")]),t._v(" "),l("li",[t._v("从库创建一个IO线程，连接主库的log dump线程，来接受主库的binlog 日志，再把binlog信息写入relay log的中继日志里，返回主库“复制成功”的响应；")]),t._v(" "),l("li",[t._v("从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性；")])]),t._v(" "),l("h3",{attrs:{id:"主从复制模型"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#主从复制模型"}},[t._v("#")]),t._v(" 主从复制模型")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("同步复制：主库提交事务的线程要等到所有从库的复制成功响应，才返回客户端结果；")])]),t._v(" "),l("li",[l("p",[t._v("异步复制（默认）：主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失；")])]),t._v(" "),l("li",[l("p",[t._v("半同步复制：事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端；")]),t._v(" "),l("blockquote",[l("p",[t._v("半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险；")])])])])])}),[],!1,null,null,null);l.default=o.exports}}]);