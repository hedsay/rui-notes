(window.webpackJsonp=window.webpackJsonp||[]).push([[142],{465:function(t,_,v){"use strict";v.r(_);var a=v(4),s=Object(a.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("blockquote",[_("p",[t._v("参考："),_("a",{attrs:{href:"https://juejin.cn/post/6844903510509633550?searchId=20231120234435449A3DCDE9A7242E5EA3#heading-11",target:"_blank",rel:"noopener noreferrer"}},[t._v("一篇文章带你熟悉 TCP/IP 协议"),_("OutboundLink")],1)]),t._v(" "),_("p",[t._v("https://juejin.cn/post/6844903510509633550?searchId=20231120234435449A3DCDE9A7242E5EA3#heading-13")])]),t._v(" "),_("h2",{attrs:{id:"三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),_("blockquote",[_("p",[t._v("指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立；")]),t._v(" "),_("p",[t._v("socket编程中，这个过程由客户端执行connect来触发；")])]),t._v(" "),_("p",[t._v("流程图：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/710ec8e91690b573ce62e62eebf2885a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"三次握手"}})]),t._v(" "),_("ol",[_("li",[_("p",[t._v("第一次握手：客户端标志位SYN置1，随机初始化一个序列号client_isn=j，将数据包发送给服务端，客户端进入SYN_SENT状态，等待服务端确认；")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230500953.png",alt:"第一个报文 —— SYN 报文"}})])]),t._v(" "),_("li",[_("p",[t._v("第二次握手：服务端接收数据包后由标志位SYN=1得知客户端请求建立连接，服务端标志位SYN和ACK置1，确认应答号置为j+1，也随机初始化一个序列号server_isn=k，并将该数据包发送给客户端以确认连接请求，服务端进入SYN_RCVD状态；")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230504118.png",alt:"第二个报文 —— SYN + ACK 报文"}})])]),t._v(" "),_("li",[_("p",[t._v("第三次握手：客户端确认后，检查确认应答号是否为j+1，ACK是否为1，是则将确认应答号置为k+1，并将数据包发送给服务端，服务端检查正确后，都进入ESTABLISHED状态；")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230508297.png",alt:"第三个报文 —— ACK 报文"}})])])]),t._v(" "),_("h3",{attrs:{id:"为什么不是两次、四次"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是两次、四次"}},[t._v("#")]),t._v(" 为什么不是两次、四次？")]),t._v(" "),_("p",[t._v("为什么不是两次？")]),t._v(" "),_("blockquote",[_("p",[t._v("阻止重复历史连接的初始化；")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230525514.png",alt:"三次握手避免历史连接"}})]),t._v(" "),_("p",[t._v("客户端连续多次发送SYN建立连接报文，在网络拥堵情况下：旧的SYN报文比新的SYN报文先到，客户端验证的服务端的确认应答号不正确就回RST报文终止连接，后续新到的SYN报文就可以正常完成三次握手；")]),t._v(" "),_("p",[t._v("如果两次握手，第一次握手就建立连接，导致服务端建立了一个历史连接，浪费服务端资源；")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/fe898053d2e93abac950b1637645943f.png",alt:"两次握手无法阻止历史连接"}})])]),t._v(" "),_("h3",{attrs:{id:"为什么初始化的序列号要求不一样"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么初始化的序列号要求不一样"}},[t._v("#")]),t._v(" 为什么初始化的序列号要求不一样？")]),t._v(" "),_("blockquote",[_("p",[t._v("防止历史报文被下一个相同四元组的连接接受；（上一个连接的数据包的序列号正好在服务端的接受窗口内）")])]),t._v(" "),_("h3",{attrs:{id:"第二次握手丢失了发生什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二次握手丢失了发生什么"}},[t._v("#")]),t._v(" 第二次握手丢失了发生什么？")]),t._v(" "),_("blockquote",[_("p",[t._v("第二次握手：SYN+ACK报文；")]),t._v(" "),_("p",[t._v("包含了ACK报文， 如果丢失，客户端会认为第一次握手的SYN报文丢失了，客户端就会触发超时重传；")]),t._v(" "),_("p",[t._v("且因为丢失了SYN报文，服务端收不到客户端发送的ACK报文，也会触发超时重传机制，重传SYN-ACK报文；")])]),t._v(" "),_("h3",{attrs:{id:"syn攻击"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#syn攻击"}},[t._v("#")]),t._v(" SYN攻击")]),t._v(" "),_("blockquote",[_("p",[t._v("攻击者短时间内伪造不同的IP地址的SYN报文， 服务端每收到一个SYN报文，就会进入SYN_RCVD状态，但服务端不知道客户端的IP，就会将服务端准备发送的ACK+SYN报文打满服务端的半连接队列；")])]),t._v(" "),_("p",[t._v("解决：")]),t._v(" "),_("blockquote",[_("p",[t._v("增大半连接队列；")]),t._v(" "),_("p",[t._v("减少SYN+ACK重传次数；")])]),t._v(" "),_("h2",{attrs:{id:"四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),_("blockquote",[_("p",[t._v("指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开；")]),t._v(" "),_("p",[t._v("在socket编程中，这一过程由客户端或服务端任一方执行close来触发；")])]),t._v(" "),_("p",[t._v("流程图：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/c901e0fd0aaae817df400b1b989a9351~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png",alt:"四次挥手"}})]),t._v(" "),_("ol",[_("li",[_("p",[t._v("第一次挥手：客户端发送一个FIN报文，关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态；")]),t._v(" "),_("blockquote",[_("p",[t._v("服务端还可以继续发送数据；")])])]),t._v(" "),_("li",[_("p",[t._v("第二次挥手：服务端收到FIN报文后，先发送ACK应答报文，进入CLOSE_WAIT状态；")]),t._v(" "),_("blockquote",[_("p",[t._v("客户端进入FIN_WAIT_2状态，继续等待服务端FIN报文；")])])]),t._v(" "),_("li",[_("p",[t._v("第三次挥手：服务端确定数据发送完成，向客户端发送FIN报文，服务端进入LAST_ACK状态；")])]),t._v(" "),_("li",[_("p",[t._v("第四次挥手：客户端收到FIN报文后，回一个ACK应答报文，进入TIME_WAIT状态；")]),t._v(" "),_("blockquote",[_("p",[t._v("服务端收到ACK报文后，进入CLOSE状态；")]),t._v(" "),_("p",[t._v("客户端经过2MSL后，自动进入CLOSE状态；")]),t._v(" "),_("p",[t._v("为什么需要经过2MSL？")]),t._v(" "),_("blockquote",[_("p",[t._v("客户端发送最后一个ACK报文，如果发送失败，服务端未收到可以重传，如果客户端等待了2MSL后未收到服务端未收到的回复，则证明服务端已正常关闭；")])]),t._v(" "),_("blockquote",[_("p",[t._v("MSL:报文最大生存时间；")])]),t._v(" "),_("p",[t._v("为什么设置2MSL？")]),t._v(" "),_("blockquote",[_("p",[t._v("发送方的数据包被接收方处理后又向对方发送ACK，一来一回需要等待2倍的时间；")])])])])]),t._v(" "),_("h3",{attrs:{id:"出现大量time-wait状态原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#出现大量time-wait状态原因"}},[t._v("#")]),t._v(" 出现大量TIME_WAIT状态原因？")]),t._v(" "),_("blockquote",[_("p",[t._v("说明服务端主动断开了很多TCP连接；")]),t._v(" "),_("p",[t._v("什么场景服务端会主动断开连接？")]),t._v(" "),_("blockquote",[_("ul",[_("li",[_("p",[t._v("没有使用长连接；")])]),t._v(" "),_("li",[_("p",[t._v("长连接超时；")]),t._v(" "),_("p",[t._v("一直使用长连接不会占用资源？")]),t._v(" "),_("blockquote",[_("p",[t._v("web服务软件一般都会提供一个参数，指定HTTP长连接超时时间，比如nginx提供的keepalive_timeout参数；")])])]),t._v(" "),_("li",[_("p",[t._v("长连接请求数达到上限；")])])])])]),t._v(" "),_("h3",{attrs:{id:"保活机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#保活机制"}},[t._v("#")]),t._v(" 保活机制")]),t._v(" "),_("blockquote",[_("p",[t._v("连接建立后，如果客户端宕机，服务端的TCP连接处于ESTABLISH状态，占用资源；")])]),t._v(" "),_("p",[t._v("解决：")]),t._v(" "),_("blockquote",[_("p",[t._v("保活机制，每隔一个时间间隔，发送一个探测报文，如果连续几个探测报文没有得到响应，则认为当前TCP连接死亡；")])])])}),[],!1,null,null,null);_.default=s.exports}}]);